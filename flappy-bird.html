<!DOCTYPE html>
<meta charset="utf-8" />

<style type="text/css">
  .player {
    fill: red;
  }

  .game {
    background-color: #70c5ce;
  }

  .pipe {
    fill: #558022;
  }

  .cloud {
    fill: white;
  }
</style>
<body></body>
<script src="./node_modules/d3/dist/d3.min.js"></script>
<script>
  // const margin = { top: 50, right: 50, bottom: 50, left: 50 };
  const width = 1000;
  const height = 600;

  const svg = d3
    .select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("class", "game")
    .append("g");

  const player = createPlayer(); //refactor or rename
  const pipeInterval = setInterval(createAndTransitionPipePair, 800);
  const cloudInterval = setInterval(createAndTransitionCloud, 800);
  const collisionInterval = setInterval(detectCollisionOfPlayer, 25);

  function createPlayer() {
    const player = svg
      .append("circle")
      .attr("class", "player")
      .attr("cx", 20)
      .attr("cy", 300)
      .attr("r", 20);
    makePlayerFall(player);

    let isMouseDown = false;
    document.body.onmousedown = function(e) {
      if (!isMouseDown) {
        isMouseDown = true;
        player
          .transition()
          .duration(100)
          .attr("cy", parseFloat(player.attr("cy")) - 50);
        makePlayerFall(player, 101);
      }
    };

    document.body.onmouseup = function(e) {
      isMouseDown = false;
    };
    return player;
  }

  function detectCollisionOfPlayer() {
    svg.selectAll(".pipe").each(function() {
      if (doRectAndCircleCollide(this, player)) {
        endGame();
      }
    });
  }

  function endGame() {
    player.transition();
    document.body.onkeydown = null;
    [cloudInterval, pipeInterval, collisionInterval].forEach(interval =>
      clearInterval(interval)
    );
    svg.selectAll("rect").transition();
  }

  function raisePlayer() {
    d3.select(".player").raise();
  }

  function createAndTransitionPipePair() {
    const shift = d3.randomUniform(-150, 150)(); // TODO make it so that the tiles can consty more but stay close to most recent value
    [-400 + shift, 400 + shift].forEach(y => {
      svg
        .append("rect")
        .attr("class", "pipe")
        .attr("x", width)
        .attr("y", y)
        .attr("width", 40)
        .attr("height", 600)
        .transition()
        .duration(2000)
        .ease(d3.easeLinear)
        .attr("x", -30)
        .remove();
    });
  }

  function createAndTransitionCloud() {
    const shift = d3.randomUniform(-15, 15)();
    svg
      .append("rect")
      .attr("class", "cloud")
      .attr("x", width)
      .attr("y", 200 + shift)
      .attr("width", 32)
      .attr("height", 35)
      .transition()
      .duration(4000)
      .ease(d3.easeLinear)
      .attr("x", -30)
      .remove();

    raisePlayer();
  }

  function makePlayerFall(play, delay = 0) {
    play
      .transition()
      .delay(delay)
      .duration(Math.sqrt(650 - play.attr("cy")) * 50)
      .attr("cy", 650)
      .ease(d3.easeQuadIn);
  }
  function doRectAndCircleCollide(rect, circle) {
    const rectAttr = ["x", "y", "width", "height"].reduce((acc, property) => {
      acc[property] = parseFloat(rect.getAttribute(property));
      return acc;
    }, {});
    const circleAttr = ["cx", "cy", "r"].reduce((acc, property) => {
      acc[property] = parseFloat(circle.attr(property));
      return acc;
    }, {});

    const distBetweenCentresX = Math.abs(
      circleAttr.cx - (rectAttr.x + rectAttr.width / 2)
    );
    const distBetweenCentresY = Math.abs(
      circleAttr.cy - (rectAttr.y + rectAttr.height / 2)
    );

    // If distance between centres is too small or to large, collsion must happen or cant happen
    if (
      distBetweenCentresX > rectAttr.width / 2 + circleAttr.r ||
      distBetweenCentresY > rectAttr.height / 2 + circleAttr.r
    ) {
      return false;
    }
    if (
      distBetweenCentresX <= rectAttr.width / 2 ||
      distBetweenCentresY <= rectAttr.height / 2
    ) {
      return true;
    }
    //pythagoras
    const dx = distBetweenCentresX - rectAttr.width / 2;
    const dy = distBetweenCentresY - rectAttr.height / 2;
    return dx * dx + dy * dy <= circleAttr.r * circleAttr.r;
  }
</script>
